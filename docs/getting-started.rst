Getting Started with QSTrader
=============================

Author: Michael Halls-Moore

Introduction to Backtesting with QSTrader
-----------------------------------------

This section will provide a tutorial on how to use the QSTrader library to begin **backtesting** your strategies. 

To introduce basic QSTrader functionality an extremely simple "buy and hold" strategy will be demonstrated. This simply goes long one hundred shares of SPY for the duration of the backtest.

Then a more interesting example will be provided, which uses a position-sizing module to adjust the weights of a simple ETF portfolio, consisting of SPY and AGG, once a month.

Finally a simple trend-following strategy will be presented that uses two simple moving averages in a crossover signal generator on AAPL.

A Basic Backtesting Example: Buy And Hold
-----------------------------------------

*Please note that the full code for this example can be found in* `buy_and_hold_backtest.py <https://github.com/mhallsmoore/qstrader/blob/master/examples/buy_and_hold_backtest.py>`_. *However if you wish to create a new file then please read on.*

In this example we are going to demonstrate a very straightforward "trading" scenario of buying a single equity and holding it until the backtest period ends. While this is far from the most exciting strategy, it will serve to show us how the basic QSTrader API is utilised.

Prior to the creation of the backtest file it is necessary to download some market data for the SPY ticker upon which the buy and hold strategy will be carried out on.

To do this it is necessary to have followed the installation instructions above so that the :code:`~/data` and :code:`~/out` directories exist. Once they do the following line can be called within a Linux shell::

    cd ~/data
    wget https://raw.githubusercontent.com/mhallsmoore/qstrader/master/data/SPY.csv

This will place the CSV file of SPY OHLCV prices into the correct directory for QSTrader to pick it up. Now that the data has been downloaded the strategy backtesting code can be created.

Firstly let's create a new file called :code:`buy_and_hold_backtest.py` to store our trading logic. We begin by importing the necessary modules::

    # buy_and_hold_backtest.py

    import datetime

    from qstrader import settings
    from qstrader.strategy.base import AbstractStrategy
    from qstrader.event import SignalEvent, EventType
    from qstrader.compat import queue
    from qstrader.trading_session import TradingSession

The Python :code:`datetime` library is needed to create the starting and ending dates of our strategy. 

One of the most important objects in QSTrader is the :code:`AbstractStrategy` class. All trading strategy objects are derived from this class and as such it must be imported. The trading strategy "logic" will live within here.

The strategy object tells the portfolio and order management system which orders to generate by sending it a :code:`SignalEvent`. This contains the ticker to be traded (e.g. AAPL or GOOG), the 'action', e.g. "buy" or "sell" and finally the number of units to transact.

The :code:`queue` object stores all of the events generated by the backtester and ties the entire system together. 

Finally, the abstract :code:`TradingSession` object is used to carry out the actual backtesting logic itself.

We will go into these objects in more detail in later, more complex, examples.

The next step is to define the :code:`BuyAndHoldStrategy` class::

    class BuyAndHoldStrategy(AbstractStrategy):
        """
        A testing strategy that simply purchases (longs) an asset
        upon first receipt of the relevant bar event and
        then holds until the completion of a backtest.
        """
        def __init__(
            self, ticker, events_queue,
            base_quantity=100
        ):
            self.ticker = ticker
            self.events_queue = events_queue
            self.base_quantity = base_quantity
            self.bars = 0
            self.invested = False

        def calculate_signals(self, event):
            if (
                event.type in [EventType.BAR, EventType.TICK] and
                event.ticker == self.ticker
            ):
                if not self.invested and self.bars == 0:
                    signal = SignalEvent(
                        self.ticker, "BOT",
                        suggested_quantity=self.base_quantity
                    )
                    self.events_queue.put(signal)
                    self.invested = True
                self.bars += 1

This class contains two methods. 

The first is the usual initialisation method :code:`__init__`. This method simply assigns many of the parameters to their respective class members. In particular it takes a :code:`ticker` parameter. This is the symbol upon which the strategy will operate, such as GOOG or MSFT. In addition it takes a handle to the events queue so that it can place events onto the queue. It also requires a 'base quantity' of shares to transact, which in this case is set to a default of 100 shares.

The second method is :code:`calculate_signals`, which contains the "trading logic" itself. Since this class inherits from :code:`AbstractStrategy` it **must** possess this method, so make sure to include it in all of your derived strategy classes. The method takes an :code:`Event` object as a parameter and checks to see if that event is either of type "Bar" or "Tick". That is, whether it is a market data event. It also checks if the event is also equal to the particular ticker that the strategy is acting upon.

If these conditions are met then the strategy checks to see if it is already invested and whether this is the first time it has seen the market data. If so it generates a new :code:`SignalEvent` with the ticker, the "BOT" buy action and a suggested quantity equal to the base quantity.

Why a *suggested* quantity and not an *actual* quantity? This is because other modules in the software, including the PositionSizer and the RiskManager, have the ability to modify order sizes in order to maintain imposed position-sizing and risk management rules.

Once the signal is generated it is placed onto the events queue and the strategy is set to be "invested".

Now that the strategy class is defined it is necessary to define a :code:`run` function that will dictate how the backtest is to be carried out::

    def run(config, testing, tickers, filename):
        # Backtest information
        title = ['Buy and Hold Example on %s' % tickers[0]]
        initial_equity = 10000.0
        start_date = datetime.datetime(2000, 1, 1)
        end_date = datetime.datetime(2014, 1, 1)

        # Use the Buy and Hold Strategy
        events_queue = queue.Queue()
        strategy = BuyAndHoldStrategy(tickers[0], events_queue)

        # Set up the backtest
        backtest = TradingSession(
            config, strategy, tickers,
            initial_equity, start_date, end_date,
            events_queue, title=title
        )
        results = backtest.start_trading(testing=testing)
        return results

The function takes a :code:`config` object, a :code:`testing` flag, a list of :code:`tickers` and an output :code:`filename`.

The first few lines include the creation of the title for the visualisation tearsheet, the initially account equity in US dollars, as well as starting and ending dates for the backtest (both specified as Python :code:`datetime` objects).

Subsequently both the :code:`events_queue` queue and the :code:`BuyAndHoldStrategy` are instantiated. 

Finally the :code:`TradingSession` is given the configuration information, the strategy itself, the list of tickers, the initial account equity, the starting/ending dates, the events queue and the tearsheet title.

To begin the backtest the :code:`backtest.start_trading(...)` method is called. The results are then returned from the :code:`run` function.

To actually execute all of this code it is necessary to include an :code:`if __name__ == "__main__"` directive::

    if __name__ == "__main__":
        # Configuration data
        testing = False
        config = settings.from_file(
            settings.DEFAULT_CONFIG_FILENAME, testing
        )
        tickers = ["SPY"]
        filename = None
        run(config, testing, tickers, filename)

This simply tells the backtest that this is not a test run. It also obtains the configuration information from the default configuration file. The backtest is carried out on the SPY S&P500 index-tracking ETF by calling the :code:`run(...)` function.

To execute the code make sure you are in the same directory as :code:`buy_and_hold_backtest.py`, change to your QSTrader virtual environment (e.g. :code:`source ~/venv/qstraderp3/bin/activate` or similar) and type::

    $ python buy_and_hold_backtest.py

The code will loop through all of the SPY OHLCV bars for each trading day between the start and ending dates of the backtest. Once it is finished you will see some brief output along with the following tearsheet:

.. image:: https://s3.amazonaws.com/quantstart/media/images/qstrader-buy-and-hold-tearsheet.png

The panels consist of a large equity curve, a drawdown chart, a monthly percentage returns heatmap, a yearly returns distribution chart as well as statistics pertaining to the strategy and trades.


A More Interesting Backtesting Example: Monthly-Rebalanced Portfolio
--------------------------------------------------------------------

*Please note that the full code for this example can be found in* `monthly_liquidate_rebalance_backtest.py <https://github.com/mhallsmoore/qstrader/blob/master/examples/monthly_liquidate_rebalance_backtest.py>`_. *However if you wish to create a new file then please read on.*

In this example we are going to build a long-only mixed ETF portfolio that maintains a dollar-weighted proportion of each ETF that rebalances at the end of every month. In particular we will create a classic "60/40 US Equities/Bonds" mix, using the SPY and AGG ETFs. 

At the start of the backtest 60% of our equity will be invested in SPY, while 40% will be invested in AGG. Since the prices will change over the month our dollar proportions will also change. The stocks will both be completely liquidated and repurchased in the correct dollar proportion at the end of every month until the backtest completes. 

Since we are already familiar with the QSTrader interface from above, we will only discuss the aspects that differ from the "buy and hold" strategy. As before it is necessary to import some Python libraries as well as the necessary QSTrader modules.

The only new additions are :code:`calendar` and :code:`LiquidateRebalancePositionSizer`. The former is needed to work out the ending day of the month, while the latter is used to actually rebalance the portfolio by adjusting suggested orders::

    # monthly_liquidate_rebalance_backtest.py

    import calendar
    import datetime

    from qstrader import settings
    from qstrader.strategy.base import AbstractStrategy
    from qstrader.position_sizer.rebalance import LiquidateRebalancePositionSizer
    from qstrader.event import SignalEvent, EventType
    from qstrader.compat import queue
    from qstrader.trading_session import TradingSession

As before it is necessary to create a strategy class that inherits from :code:`AbstractStrategy`. This will be called :code:`MonthlyLiquidateRebalanceStrategy`::

    class MonthlyLiquidateRebalanceStrategy(AbstractStrategy):
        """
        A generic strategy that allows monthly rebalancing of a
        set of tickers, via full liquidation and dollar-weighting
        of new positions.

        Must be used in conjunction with the
        LiquidateRebalancePositionSizer object to work correctly.
        """
        def __init__(self, tickers, events_queue):
            self.tickers = tickers
            self.events_queue = events_queue
            self.tickers_invested = self._create_invested_list()

        def _end_of_month(self, cur_time):
            """
            Determine if the current day is at the end of the month.
            """
            cur_day = cur_time.day
            end_day = calendar.monthrange(cur_time.year, cur_time.month)[1]
            return cur_day == end_day

        def _create_invested_list(self):
            """
            Create a dictionary with each ticker as a key, with
            a boolean value depending upon whether the ticker has
            been "invested" yet. This is necessary to avoid sending
            a liquidation signal on the first allocation.
            """
            tickers_invested = {ticker: False for ticker in self.tickers}
            return tickers_invested

        def calculate_signals(self, event):
            """
            For a particular received BarEvent, determine whether
            it is the end of the month (for that bar) and generate
            a liquidation signal, as well as a purchase signal,
            for each ticker.
            """
            if (
                event.type in [EventType.BAR, EventType.TICK] and
                self._end_of_month(event.time)
            ):
                ticker = event.ticker
                if self.tickers_invested[ticker]:
                    liquidate_signal = SignalEvent(ticker, "EXIT")
                    self.events_queue.put(liquidate_signal)
                long_signal = SignalEvent(ticker, "BOT")
                self.events_queue.put(long_signal)
                self.tickers_invested[ticker] = True

It contains four methods: :code:`__init__`, :code:`_end_of_month`, :code:`_create_invested_list` and :code:`calculate_signals`. 

The initialisation method is similar to the "buy and hold" example except that it creates a :code:`tickers_invested` dictionary to store boolean values as to whether a ticker has currently been purchased or not. This is created by the :code:`_create_invested_list` method.

The :code:`_end_of_month` method is needed to check if the current market data point day is the ending day of the month.

As with all derived strategy classes the :code:`calculate_signals` method is used to store the trading logic. It checks whether a market event has been received and that it is the ending day of the month. If so, it generates a suggested long signal. The strategy then keeps track of whether that ticker has been "invested".

The rebalancing logic itself is kept in a class called the :code:`LiquidateRebalancePositionSizer`, which is a derived class from a generic QSTrader object known as a :code:`PositionSizer`. 

The rationale for this class is to allow an overlay module to modify, delete or veto orders based on position-sizing logic. In this instance it is necessary to rebalance the portfolio once a month in order to maintain a dollar-weighted proportion as described above. We don't need to provide this logic here as the position sizing object will do it for us. We simply need to import it and make use of it in our :code:`Trading Session`.

Let's now create the :code:`run(...)` function as we did in the "buy and hold" strategy::

    def run(config, testing, tickers, filename):
        # Backtest information
        title = [
            'Monthly Liquidate/Rebalance on 60%/40% SPY/AGG Portfolio'
        ]
        initial_equity = 500000.0
        start_date = datetime.datetime(2006, 11, 1)
        end_date = datetime.datetime(2016, 10, 12)

        # Use the Monthly Liquidate And Rebalance strategy
        events_queue = queue.Queue()
        strategy = MonthlyLiquidateRebalanceStrategy(
            tickers, events_queue
        )

        # Use the liquidate and rebalance position sizer
        # with prespecified ticker weights
        ticker_weights = {
            "SPY": 0.6,
            "AGG": 0.4,
        }
        position_sizer = LiquidateRebalancePositionSizer(
            ticker_weights
        )

        # Set up the backtest
        backtest = TradingSession(
            config, strategy, tickers,
            initial_equity, start_date, end_date,
            events_queue, position_sizer=position_sizer,
            title=title, benchmark=tickers[0],
        )
        results = backtest.start_trading(testing=testing)
        return results

As you can see it is somewhat more complex than before. The title has changed, but the code for the equity and dates are largely the same. The strategy is instantiated as before but new code has been added before the :code:`TradingSession` is instantiated.

In particular a :code:`ticker_weights` dictionary has been defined that provides tickers as keys and a proportion (between 0 and 1) as values. This is then fed into the instantiated :code:`LiquidateRebalancePositionSizer` position sizing object.

The :code:`TradingSession` is then created. Most of the parameters are the same as the "buy and hold" example but there some new ones here. The :code:`position_sizer` keyword argument is set equal to the :code:`position_sizer` object. A :code:`benchmark` keyword argument is set to the first ticker, namely SPY. This produces a benchmark equity curve in the visual tearsheet at the conclusion of the backtest.

Finally the backtest is executed with :code:`backtest.start_trading(...)`.

As before we need to create an :code:`if __name__ == "__main__"` directive::

    if __name__ == "__main__":
        # Configuration data
        testing = False
        config = settings.from_file(
            settings.DEFAULT_CONFIG_FILENAME, testing
        )
        tickers = ["SPY", "AGG"]
        filename = None
        run(config, testing, tickers, filename)

It is extremely similar to the one produced for the "buy and hold" example except that :code:`tickers` contains both SPY and AGG.

To run the code (similarly to above) simply type::

    $ python monthly_liquidate_rebalance_backtest.py

The code will loop through all of the SPY and AGG OHLCV bars for each trading day between the start and ending dates of the backtest. Once it is finished you will see some brief output along with the following tearsheet:

.. image:: https://s3.amazonaws.com/quantstart/media/images/qs-qstrader-monthly-rebalance-spy-agg-tearsheet.png

As can be seen the performance of the portfolio is not great. It fails to beat the benchmark (in grey) of going long SPY on its own. 

A Trend-Following Backtesting Example: Moving Average Crossover
---------------------------------------------------------------